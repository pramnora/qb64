**CRYPTOGRAPHY links**

**ROT13/(ROTate 13)**
* https://en.wikipedia.org/wiki/ROT13  
* http://www.rot13.com  

-----

**ROT13 chart**

ROT 13/or, ROTate 13...is a very simple alphabet code.

Basically, you...

- divide up the English 26 letter alphabet...into 2/so, 26 divided by 2 = 13;
- next, you write out each letter of the alphabet into being 2 separate rows;    
  with each row containing 13 characters...one row going on top of the other;  
  also, the alphabet is written down on each line, always, going from 'left to right'.  

> A B C D E F G H I J K L M  
> N O P Q R S T U V W X Y Z

-(The letter, below...corresponds to the letter being written directly on top of it;     
  the letter, on top...corresponds to the letter which is written directly down below;    
  so, A, is translated to become, N;    
  and, N, is translated to become, A.)-      

...and, now, you are all set to do your 'encoding/decoding' process...as the following example shows:

**Encode:** ABC = NOP  
**Decode:** NOP = ABC  

Of course, it helps if you were to write a computer program to help solve this task...;         
which is because the computer works so much *faster* at doing both the 'encoding/decoding' process;    
than would any human being who has to process it, either:

 - manually, inside of their own mind    
 - or else, by writing it down by hand onto paper  
 
...and, so, it is for these reasons why the computer is really best suited to dealing with and solving *cryptograpy* problems;    
because it works at 'electronic' speeds; and, also, is **guaranteed** to make nil mistakes!  

**Encode:** Thisisasecretmessage = GUVFVFNFRPERGZRFFNTR  
**Decode:** GUVFVFNFRPERGZRFFNTR = THISISASECRETMESSAGE   

-----

**ALGORITHMS**

It is certainly worthwhile noting that, quite often, in the computing world;    
what truly matters most...is NOT the programming language itself;  
this is because many different programming languages can be used to solve exactly the same task;  
so, it really doesn't matter if we write the code using: C/C++/Java/Javascript/BASIC/-etc.;  
instead, what really matters is our careful *understanding* of the underlying 'step by step' **ALGORITHM**;    
an **ALGORITHM** meaning...

> breaking down/and, then, solving problems, very carefully, step by step.  

Frankly, what might seem like being a next to impossible task to *begin* with...?  
Through having latched on to the **correct** algorithm....;  
then, all of a sudden, everything becomes really quite 'crystal clear';      
and, then, all of a sudden, we find we are having a Eureka moment! ;-)  
